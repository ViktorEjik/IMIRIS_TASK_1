# IMIRIS_TASK_1

## Задание
Добавить к исходной модели второй сервер. При этом оставьте одну очередь, в которую поступают запросы всех клиентов. Как только i-й сервер освободится, он берет задание из очереди. Если в момент освобождения оба сервера свободны, то первый раз задание забирает первый, второй раз – второй, третий – первый, и т.д.

## Ход решения
Создан новый класс $Server$, представляющий абстракцию вычислителя. Класс обладает приватными полями $cpu\_state$ и $ID$ и публичными методами:

1) Конструктор (в качестве параметра принимает ID вычислителя)
2) get_cpu_state (возвращает состояние вычислителя)
3) set_task (переводит вычичлитель в состояние подсчёта)
4) drop_task (переводит вычислитель в состояние готовность)

В коде планировщика изменился блок распределения задач из очереди и облок связаный с завершением задачи.

## Блок распределениия задач
Реализовон выбор вычислителя ПРиблизительный код:
```
        if (server_0.geet_cpu_state() == IDLE)
        {
          current_server = &server_0;
        }
        else if(server_1.get_cpu_state() == IDLE)
        {
          current_server = &server_1;
        }

        if(current_server != nullptr) 
        { 
          int FIN_FLAG = current_server->set_task();
          calendar.put(new Event(curr_time+dt, FIN_FLAG, curr_ev->attr));
          run_begin = curr_time;
        } 
        else queue.push_back(new Request(dt, curr_ev->attr)); 
```

## Блок завершения задачи
Блок завершения задачи был разбит на два блока, первый отвечает за завершениие работы первого вычислителя второй второго.
